const fs = require("fs");
const path = require("path");

const DEFAULT_RULESET_NAME = "agent-ruleset.json";
const DEFAULT_IGNORE_DIRS = new Set([
  ".git",
  "agent-rules",
  "agent-rules-private",
  "agent-rules-local",
  "agent-rules-tools",
  "node_modules",
  "dist",
  "build",
  "out",
  ".next",
  ".turbo",
  "coverage"
]);

const usage = `Usage: node agent-rules-tools/tools/compose-agents.cjs [--root <path>] [--ruleset <path>] [--ruleset-name <name>]

Options:
  --root <path>         Project root directory (default: current working directory)
  --ruleset <path>      Only compose a single ruleset file
  --ruleset-name <name> Ruleset filename to search for (default: agent-ruleset.json)
`;

const parseArgs = (argv) => {
  const args = {};

  for (let i = 0; i < argv.length; i += 1) {
    const arg = argv[i];

    if (arg === "--help" || arg === "-h") {
      args.help = true;
      continue;
    }

    if (arg === "--root") {
      args.root = argv[i + 1];
      i += 1;
      continue;
    }

    if (arg === "--ruleset") {
      args.ruleset = argv[i + 1];
      i += 1;
      continue;
    }

    if (arg === "--ruleset-name") {
      args.rulesetName = argv[i + 1];
      i += 1;
      continue;
    }

    throw new Error(`Unknown argument: ${arg}`);
  }

  return args;
};

const normalizeTrailingWhitespace = (content) => content.replace(/\s+$/u, "");
const normalizePath = (filePath) => filePath.replace(/\\/g, "/");

const resolveFrom = (baseDir, targetPath) => {
  if (path.isAbsolute(targetPath)) {
    return targetPath;
  }

  return path.resolve(baseDir, targetPath);
};

const ensureFileExists = (filePath) => {
  if (!fs.existsSync(filePath)) {
    throw new Error(`Missing file: ${filePath}`);
  }
};

const readRuleset = (rulesetPath) => {
  const raw = fs.readFileSync(rulesetPath, "utf8");
  const parsed = JSON.parse(raw);

  if (typeof parsed.output !== "string" || parsed.output.trim() === "") {
    throw new Error(`Invalid ruleset output in ${rulesetPath}`);
  }

  if (!Array.isArray(parsed.rules) || parsed.rules.length === 0) {
    throw new Error(`Invalid ruleset rules in ${rulesetPath}`);
  }

  return parsed;
};

const composeRuleset = (rulesetPath, rootDir) => {
  const rulesetDir = path.dirname(rulesetPath);
  const ruleset = readRuleset(rulesetPath);
  const outputPath = resolveFrom(rulesetDir, ruleset.output);

  const parts = ruleset.rules.map((rulePath) => {
    const resolvedRulePath = resolveFrom(rulesetDir, rulePath);
    ensureFileExists(resolvedRulePath);
    return normalizeTrailingWhitespace(fs.readFileSync(resolvedRulePath, "utf8"));
  });

  const relativeRuleset = normalizePath(path.relative(rootDir, rulesetPath));
  const lintHeader = "<!-- markdownlint-disable MD025 -->";
  const header = [
    "<!--",
    "  Generated by agent-rules-tools/tools/compose-agents.cjs.",
    `  Source: ${relativeRuleset}`,
    "-->",
    ""
  ].join("\n");

  const output = `${lintHeader}\n${header}${parts.join("\n\n")}\n`;

  fs.mkdirSync(path.dirname(outputPath), { recursive: true });
  fs.writeFileSync(outputPath, output, "utf8");

  return normalizePath(path.relative(rootDir, outputPath));
};

const findRulesetFiles = (rootDir, rulesetName) => {
  const results = [];
  const pending = [rootDir];

  while (pending.length > 0) {
    const currentDir = pending.pop();
    const entries = fs.readdirSync(currentDir, { withFileTypes: true });

    for (const entry of entries) {
      const entryPath = path.join(currentDir, entry.name);

      if (entry.isDirectory()) {
        if (DEFAULT_IGNORE_DIRS.has(entry.name)) {
          continue;
        }
        pending.push(entryPath);
        continue;
      }

      if (entry.isFile() && entry.name === rulesetName) {
        results.push(entryPath);
      }
    }
  }

  return results;
};

const getRulesetFiles = (rootDir, specificRuleset, rulesetName) => {
  if (specificRuleset) {
    const resolved = resolveFrom(rootDir, specificRuleset);
    ensureFileExists(resolved);
    return [resolved];
  }

  return findRulesetFiles(rootDir, rulesetName);
};

const main = () => {
  const args = parseArgs(process.argv.slice(2));

  if (args.help) {
    process.stdout.write(`${usage}\n`);
    return;
  }

  const rootDir = args.root ? path.resolve(args.root) : process.cwd();
  const rulesetName = args.rulesetName || DEFAULT_RULESET_NAME;
  const rulesetFiles = getRulesetFiles(rootDir, args.ruleset, rulesetName);

  if (rulesetFiles.length === 0) {
    throw new Error(`No ruleset files named ${rulesetName} found under ${rootDir}`);
  }

  const outputs = rulesetFiles
    .sort()
    .map((rulesetPath) => composeRuleset(rulesetPath, rootDir));

  process.stdout.write(`Composed AGENTS.md:\n${outputs.map((file) => `- ${file}`).join("\n")}\n`);
};

try {
  main();
} catch (error) {
  process.stderr.write(`${error.message}\n`);
  process.stderr.write(`${usage}\n`);
  process.exit(1);
}

